# Тема 8. Основы объектно-ориентированного программирования
Отчет по Теме #8 выполнил(а):
- Бойков Егор Сергеевич
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.

```python
#Создание класса Car
class Car:
    #Метод инициализации класса
    def __init__(self, make, model):
        #Присваивание параметров make и model атрибутам экземпляра
        self.make = make
        self.model = model

#Создание экземпляра класса Car с производителем mak и моделью III
car = Car("mak", "III")
```
### Результат.
![alt text](pc/1.png)
## Выводы
В ходе выполнения первого задания был создан класс Car с базовыми атрибутами, отражающими производителя и модель автомобиля. Объект класса успешно продемонстрировал способность хранить и отображать эти данные. Данный опыт закрепил базовые навыки работы с атрибутами и методами класса.


## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
# Определение класса Car, представляющего автомобиль
class Car:
    # Инициализация объекта класса Car с атрибутами make и model
    def __init__(self, make, model):
        self.make = make  # Марка автомобиля
        self.model = model  # Модель автомобиля

    # Метод drive, который выводит сообщение о том, что автомобиль едет
    def drive(self):
        print(f"Driving the {self.make} {self.model}")  # Вывод информации о марке и модели автомобиля

# Создание объекта класса Car с маркой "mak" и моделью "III"
my_car = Car("mak", "III")
# Вызов метода drive для объекта my_car
my_car.drive()
```
### Результат.
![alt text](pc/2.png)
## Выводы
На основе класса Car добавлены дополнительные методы, позволяющие автомобилю “ехать”, что демонстрирует расширение функциональности класса. Задание помогло усвоить принципы добавления новых методов в классы, а также акцентировало внимание на удобстве вызова этих методов для взаимодействия с объектами.


## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.


```python
# Определение класса Car, представляющего обычный автомобиль
class Car:
    # Инициализация объекта класса Car с атрибутами make и model
    def __init__(self, make, model):
        self.make = make  # Марка автомобиля
        self.model = model  # Модель автомобиля

    # Метод drive, который выводит сообщение о том, что автомобиль едет
    def drive(self):
        print(f"Driving the {self.make} {self.model}")  # Вывод информации о марке и модели автомобиля

# Определение класса ElectricCar, который наследует класс Car
class ElectricCar(Car):
    # Инициализация объекта класса ElectricCar с дополнительным атрибутом battery_capacity
    def __init__(self, make, model, battery_capacity):
        # Вызов конструктора базового класса Car для инициализации make и model
        super().__init__(make, model)
        self.battery_capacity = battery_capacity  # Емкость батареи в киловатт-часах (kWh)

    # Метод charge, который выводит сообщение о зарядке электромобиля
    def charge(self):
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")  # Вывод информации о процессе зарядки

# Создание объекта класса ElectricCar с маркой "mak", моделью "IV" и емкостью батареи 111 kWh
my_electric_car = ElectricCar("mak", "IV", 111)
# Вызов метода drive для объекта my_electric_car
my_electric_car.drive()
# Вызов метода charge для объекта my_electric_car
my_electric_car.charge()

```
### Результат.
![alt text](pc/3.png)
## Выводы
Создание класса-наследника ElectricCar добавило в базовый класс Car новую функциональность, связанную с электромобилем, его зарядкой и емкостью батареи. Наследование позволило использовать методы родительского класса и продемонстрировало преимущества повторного использования кода.



## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.


```python
# Определение класса Car, представляющего автомобиль
class Car:
    # Инициализация объекта класса Car с атрибутами make и model
    def __init__(self, make, model):
        self._make = make         # Защищённый (protected) атрибут make, доступен внутри класса и для наследников
        self.__model = model      # Приватный (private) атрибут model, доступен только внутри этого класса

    # Метод drive, который выводит сообщение о том, что автомобиль едет
    def drive(self):
        print(f"Driving the {self._make} {self.__model}")  # Доступ к защищённому и приватному атрибутам внутри класса

# Создание объекта класса Car с маркой "mak" и моделью "II"
my_car = Car("mak", "II")

# Доступ к защищённому атрибуту _make вне класса допустим, но рекомендуется избегать его прямого изменения
print(my_car._make)

# Попытка доступа к приватному атрибуту __model вызовет ошибку, так как он скрыт от внешнего доступа
# print(my_car.__model)  # Раскомментировав, получим ошибку AttributeError

# Вызов метода drive для объекта my_car
my_car.drive()

```
### Результат.
![alt text](pc/4.png)

## Выводы
Реализована инкапсуляция: добавлены защищённые и приватные атрибуты, что ограничивает доступ к данным. Это закрепило знания об уровнях доступа к атрибутам и важности защиты данных внутри классов.



## Лабораторная работа №5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.




```python
# Определение базового класса Shape, представляющего общую форму
class Shape:
    # Метод area, который должен быть определён в подклассах
    def area(self):
        pass  # Пустой метод, который переопределяется в дочерних классах

# Определение класса Rectangle, наследующего Shape
class Rectangle(Shape):
    # Инициализация объекта класса Rectangle с параметрами ширины и высоты
    def __init__(self, width, height):
        self.width = width    # Ширина прямоугольника
        self.height = height  # Высота прямоугольника

    # Переопределение метода area для вычисления площади прямоугольника
    def area(self):
        return self.width * self.height  # Площадь прямоугольника = ширина * высота

# Определение класса Circle, наследующего Shape
class Circle(Shape):
    # Инициализация объекта класса Circle с параметром радиуса
    def __init__(self, radius):
        self.radius = radius  # Радиус круга

    # Переопределение метода area для вычисления площади круга
    def area(self):
        return 3.14 * self.radius * self.radius  # Площадь круга = π * радиус^2

# Создание списка фигур, содержащего экземпляры Rectangle и Circle
arr = [Rectangle(12, 67), Circle(41)]

# Перебор элементов списка и вывод площади каждой фигуры
for elem in arr:
    print(elem.area())  # Вызов метода area для каждого объекта в списке

```
### Результат.
![alt text](pc/5.png)

## Выводы
Создан полиморфный класс Shape с дочерними классами Rectangle и Circle, каждый из которых имеет собственную реализацию метода area. Полиморфизм позволил вызвать метод area для объектов разных классов, что подтвердило возможность гибкого использования классов с одинаковыми методами, но различной реализацией.


## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self,name, zzz):
        self.name = name
        self.zzz = zzz
    def sayName(self):
        print(f"Меня ховут {self.name}")
    def sound(self):
        print(self.zzz)
M = Animal("Корова","муму")
M.sayName()
M.sound()
```
### Результат.
![alt text](pc/11.png)

## Выводы
В данной работе был создан класс Animal с атрибутами имени и звука, а также методами для их отображения. Это позволило закрепить навыки создания и инициализации собственных классов и объектов, а также взаимодействия с атрибутами и методами.



## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self,name, zzz):
        self.name = name
        self.zzz = zzz
    def sayName(self):
        print(f"Меня ховут {self.name}")
    def sound(self):
        print(self.zzz)
    def go(self):
        print("топ топ")
M = Animal("Корова","муму")
M.sayName()
M.sound()
M.go()
```
### Результат.
![alt text](pc/12.png)

## Выводы
Добавлены новые атрибуты и методы к классу Animal, что расширило функционал и дало возможность объектам выполнять дополнительные действия. Эта работа позволила лучше понять принципы добавления новых свойств к уже существующим классам и методам.


## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self,name, zzz):
        self.name = name
        self.zzz = zzz
    def sayName(self):
        print(f"Меня ховут {self.name}")
    def sound(self):
        print(self.zzz)
    def go(self):
        print("топ топ")
class dog(Animal):
    def __init__(self,name,zzz):
        super().__init__(name,zzz)
        
M = Animal("Корова","муму")
D = dog("Собака", "гав гав")
D.sound()
```
### Результат.
![alt text](pc/13.png)

## Выводы
Реализовано наследование с созданием класса dog, унаследовавшего свойства и методы от Animal. Это закрепило навыки наследования, показав, как можно использовать и расширять базовый класс, создавая более специфичные подклассы.


## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self,name, zzz):
        self._name = name
        self.__zzz = zzz
    def sayName(self):
        print(f"Меня ховут {self._name}")
    def sound(self):
        print(self.__zzz)
    def go(self):
        print("топ топ")
class dog(Animal):
    def __init__(self,name,zzz):
        super().__init__(name,zzz)
        
M = Animal("Корова","муму")
D = dog("Собака", "гав гав")
D.sound()
```
### Результат.
![alt text](pc/14.png)

## Выводы
Была реализована инкапсуляция с использованием защищённых и приватных атрибутов, что ограничивает доступ к данным. Задание помогло усвоить различия между уровнями доступа к данным и важность защиты информации внутри классов.


## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self,name, zzz):
        self._name = name
        self.__zzz = zzz
    def sayName(self):
        print(f"Меня ховут {self._name}")
    def sound(self):
        print(self.__zzz)
    def go(self):
        print("топ топ")
class dog(Animal):
    def __init__(self,name,zzz):
        super().__init__(name,zzz)
    def go(self):
        print("прыг скок")
        
M = Animal("Корова","муму")
D = dog("Собака", "гав гав")
D.sound()
D.go()
```
### Результат.
![alt text](pc/15.png)

## Выводы
В классе-наследнике dog был переопределён метод go, демонстрируя полиморфизм в действии. Это позволило увидеть, как можно изменять поведение методов в дочерних классах, что добавляет гибкости и позволяет адаптировать функциональность под разные нужды.

## Общие выводы по теме
В ходе выполнения всех заданий были изучены и успешно применены ключевые концепции объектно-ориентированного программирования: инкапсуляция, наследование, полиморфизм и работа с классами. Это заложило фундамент для создания структурированного и гибкого кода, а также позволило понять, как использовать основные принципы ООП для решения различных задач в программировании.











